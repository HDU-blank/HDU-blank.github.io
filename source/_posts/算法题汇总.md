---
title: 算法汇总
date: 2019-03-19 19:54:00
tags: [js, 算法]
---
### 1. Fisher–Yates 洗牌算法
> 问题描述：玩德州扑克前，需要进行洗牌，以随机的牌序来确保一个公平的游戏。把一副牌看做一个一维数组，问题就转换为如何去随机打乱一个数组。

解题思路： 每次从未放置的区域随机选取一个元素放到数组末位，直到所有元素已被放置。

```
/**
 * @param {number[]} nums
 * @return {number[]}
 */

function shuffle(nums) {
    let n = nums.length;
    while (len) {
        let j = Math.floor(Math.random() * n--);	// 随机获取未放置区元素下标[0, n-1]
        [nums[j], nums[n]] = [nums[n], nums[j]];
    }
}
```
<!--more-->
### 2. 埃拉托斯特尼筛法
> 问题描述：计数质数。统计所有小于非负整数 n 的质数的数量。

解题思路： 要得到自然数n以内的全部素数，必须把不大于 &radic;n 的所有素数的倍数剔除，剩下的就是素数。

```
/**
 * @param {number} n
 * @return {number}
 */

var countPrimes = function(n) {
    let count = 0;
    if (n<=1) return count;
    for (let i=2; i<n; i++) {
        if(i===2 || i===3) {
            count++;
            continue;
        }
        if(i%2===0 || i%3===0){
            continue;
        }
        let nonPrime = 0;
        for(let j=5;j*j<=i;j+=6) {
            if (i%j===0 || i%(j+2)===0) {
                nonPrime = 1;break;
            }
        }
        if(!nonPrime) count++;
    }
    return count;
};
```
### 3. KMP算法
> 问题描述：字符串（也叫主串）中的模式（pattern）定位问题。模式串就是关键字，如果它在一个主串中出现，就返回它的具体位置，否则返回-1。

```
/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */
// next数组实现
var kmpNext = function(str) {
	let i = 0,
		j = 1,
		next = new Array(str.length);
		next[0] = 0;
	while(j < str.length){
		if (str[i] === str[j]){
			next[j] = i+1
			i++;
			j++;
		}else if(i==0){
			next[j] = 0;
			j++;
		}else{
			i = next[i-1];
		}
	}
	return next;
}

var strStr = function(haystack, needle) {
	if (needle === '') return 0;
	var index = [],
        lenStr = haystack.length,
        lenSub = needle.length,
        next = kmpNext(needle),
        i = 0,
        j = 0;
    while(i < lenStr && j < lenSub){
        if(haystack[i] === needle[j]){
            i++;
            j++;
            if (j === lenSub){
                index.push(i-lenSub);
                j = 0;
            }
        } else if (j === 0){
            i++;
        } else{
            j = next[j - 1];
        }
    }
    return index.length > 0 ? index : -1;
};
```

#### KMP算法优化
