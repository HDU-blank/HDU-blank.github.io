---
title: 函数节流和函数防抖
date: 2019-03-14 12:57:00
tags: [js, 节流, 防抖]
---
#### JavaScript函数节流和函数防抖之间的区别
函数节流和函数防抖，两者都是优化高频率执行js代码的一种手段。
* **函数节流是指一定时间内js方法只执行一次**。比如公交车，就是一定时间内发车一次。
* **函数防抖是指频繁触发的情况下，只有足够的延迟时间，才执行代码一次**。比如感应门禁，就是在一定时间内，如果有人陆续进门，门就不会关。只有一定间隔没人进门触发感应，门才会关。
##### 应用场景区别
* **函数节流** 多数在监听页面元素滚动事件的时候会用到，不要求一定要执行最新一次js方法
* **函数防抖** 最常见的就是用户注册时候的手机号码验证和邮箱验证了。只有等用户输入完毕后，前端才需要检查格式是否正确，如果不正确，再弹出提示语。（需要执行最新一次的js方法）
* **总结**：**节流**相当于把触发之后的js方法都return，而**防抖**相当于把触发之前的js方法都销毁。
<!--more-->
##### 函数实现
**函数节流**的要点是，声明一个变量当标志位，记录当前代码是否在执行。<br>
如果空闲，则可以正常触发方法执行。<br>
如果代码正在执行，则取消这次方法执行，直接return。<br>
```
// 节流
let canRun = true;
const throttle = (fn, wait, canRun) => {
    let timeout;
    return (...args) => {
        if(!canRun){
            // 判断是否已空闲，如果在执行中，则直接return
            return;
        }
        canRun = false;
        clearTimeout(timeout);
        timeout = setTimeout(function(){
            fn.apply(this, args);
            canRun = true;
        }, wait);
    };
};
```
**函数防抖**的要点，也是需要一个`setTimeout`来辅助实现。延迟执行需要跑的代码。<br>
如果方法多次触发，则把上次记录的延迟执行代码用`clearTimeout`清掉，重新开始。<br>
如果计时完毕，没有方法进来访问触发，则执行代码。<br>
```
// 去抖动 immediate是否立即执行一次
function debounce(fn, wait, immediate = false) {
    let timeout;
    return (...args) => {
        let late = () => {
            timeout = null;
            if (!immediate) {
                fn.apply(this, args);
            }
        };
        let callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(late, wait);
        if (callNow) {
            fn.apply(this, args);
        }
    };
}
```
